# Prints a color gradient to test truecolor support
colortest() {
  awk 'BEGIN{
      s=" "; s=s s s s s s s s;
      for (colnum = 0; colnum<77; colnum++) {
          r = 255-(colnum*255/76);
          g = (colnum*510/76);
          b = (colnum*255/76);
          if (g>255) g = 510 - g;
          printf "\033[48;2;%d;%d;%dm%s\033[0m", r,g,b,substr(s,colnum%8+1,1);
      }
      printf "\n";
  }'
}

# Show all apps manually installed by user
# Supports: Linux Mint, Ubuntu, Debian, Fedora, Arch
installed-apps() {
  if [ -f /etc/os-release ]; then
    . /etc/os-release
    DISTRO=$ID
  else
    echo "Cannot detect distribution"
    return 1
  fi

  case $DISTRO in
    linuxmint)
      # Linux Mint: use gsettings tracking
      # tr -d "[]'" cleans up the array syntax
      # tr ', ' ' \n' replaces every comma+space with space+newline
      gsettings get com.linuxmint.install installed-apps | tr -d "[]'" | tr ', ' ' \n'
      ;;
    ubuntu|debian|pop|neon)
      # Ubuntu/Debian: show manually installed packages (not dependencies)
      comm -23 <(apt-mark showmanual | sort) <(gzip -dc /var/log/installer/initial-status.gz 2>/dev/null | sed -n 's/^Package: //p' | sort)
      ;;
    fedora|rhel|centos)
      # Fedora/RHEL: packages explicitly installed by user
      dnf repoquery --userinstalled --qf '%{name}' | grep -v -E '(^\@|kernel|dnf|systemd|grub)'
      ;;
    arch|manjaro)
      # Arch: explicitly installed packages (not dependencies)
      pacman -Qe | awk '{print $1}'
      ;;
    *)
      echo "Unsupported distribution: $DISTRO"
      return 1
      ;;
  esac
}

# Download entire website with wget
wgetsite() {
    if [ -z "$1" ]; then
        echo "Usage: wgetsite <url>"
        echo "Example: wgetsite https://example.com/docs/"
        return 1
    fi
    wget -r -np -k -p -E "$1"
    # -r = recursive
    # -np = no parent
    # -k = convert links to local files
    # -p = page requisites (download images, css, js, etc.)
    # -E = use .html extension
}

# ┌───────────────────────┐
# │    FZF and Ripgrep    │
# └───────────────────────┘

# fuzzy cd
fcd() {
  local dir
  dir=$(find . -type d -not -path '*/\.*' | fzf) && cd "$dir"
}

# fuzzy shell history
fsh() {
  eval "$(history | fzf | sed 's/ *[0-9]* *//')"
}

# search by file name
rgf() {
  rg --files --iglob "*$1*"
}

# ┌───────────────────────┐
# │          Git          │
# └───────────────────────┘

git-upstream() {
  git remote set-url origin "$1"
}

git-hardsync() {
	git fetch upstream
	git checkout main
	git reset --hard upstream/main
}

prune-branches() {
  # Capture pruned remote branches
  pruned_branches=$(git fetch -p 2>&1 | grep '\[deleted\]' | sed -E 's/.*-> origin\///')

  if [[ -z "$pruned_branches" ]]; then
      echo "No pruned branches. Nothing to do."
      exit 0
  fi

  echo "Remote branches pruned:"
  echo "$pruned_branches"
  echo

  # Loop through each pruned branch
  for pruned in $pruned_branches; do
      if git show-ref --verify --quiet "refs/heads/$pruned"; then
          read -p "Local branch '$pruned' matches a just-pruned remote. Delete? [y/N] " confirm
          if [[ $confirm == [yY] ]]; then
              git branch -D "$pruned"
          fi
      fi
  done
}

# ┌───────────────────────┐
# │         CI/CD         │
# └───────────────────────┘

diff-workflows() {
  BASE_DIR="$projects/.scripts/github_workflows" 
  TARGET_DIR="$(pwd)/.github/workflows"

  if diff -qr "$BASE_DIR" "$TARGET_DIR" > /dev/null; then
      echo "✅ No differences between $BASE_DIR and $TARGET_DIR"
      exit 0
  else
      echo "❌ Differences detected between $BASE_DIR and $TARGET_DIR"
      exit 1
  fi
}